---
title: Основы Node и Express
data: 18.12.2019
---

## Введение

Node.js - это среда выполнения JavaScript, которая позволяет разработчикам писать бэкэнд (серверные) программы на JavaScript. Node.js поставляется с несколькими встроенными модулями - небольшими независимыми программами, которые помогают облегчить эту задачу. Некоторые из основных модулей включают в себя:

+ HTTP: модуль, который действует как сервер
+ File System: модуль, который читает и изменяет файлы
+ Path: модуль для работы с каталогами и путями к файлам
+ Assertion Testing: модуль, который проверяет код на соответствие предписанным ограничениям

Express является еще одним модулем, который часто используется с Node.js, но не входит в него. Express - это фреймворк web-приложений для Node.js. Express выполняется между созданным Node.js сервером и фронтендом веб-приложения. Express также обрабатывает маршрутизацию приложения. Маршрутизация направляет пользователей на нужную страницу в зависимости от их взаимодействия с приложением. Хотя существуют альтернативы использованию Express, его простота делает его хорошим местом для начала при изучении взаимодействия между бэкэндом, работающим на Node.js и фронтендом.

Работа над этими заданиями будет включать в себя написание кода на Glitch в нашем стартовом проекте. После завершения каждого задания вы можете скопировать свой публичный URL-адрес Glitch (на домашнюю страницу вашего приложения) в экран задания, чтобы проверить его! При желании вы можете написать свой проект на другой платформе, но он должен быть публично виден для нашего тестирования.

Запустите этот проект на Glitch с помощью шаблона [Backend Challenges Boilerplate](https://glitch.com/edit/#!/remix/clone-from-repo?REPO_URL=https://github.com/freeCodeCamp/boilerplate-express/) (необходимо, если вы используете Glitch) или клонируйте [этот репозиторий](https://github.com/freeCodeCamp/boilerplate-express/) на GitHub! Если вы используете Glitch, не забудьте сохранить ссылку на ваш проект в безопасном месте!

## Знакомство с консолью Node

В процессе разработки важно иметь возможность проверить, что происходит в вашем коде. Node - это просто среда выполнения JavaScript. Как и на клиентском JavaScript, вы можете использовать консоль для отображения полезной отладочной информации. На локальном компьютере вы увидите консоль вывода в терминале. На Glitch вы можете открыть логи в нижней части экрана. Вы можете переключить панель журнала с помощью кнопки ‘Logs’ (внизу слева, в меню "Tools").

Мы рекомендуем держать панель журнала открытой во время работы над этими заданиями. Читая журналы, вы можете быть осведомлены о характере ошибок, которые могут возникнуть.

Если вы еще не сделали этого, пожалуйста, прочитайте инструкцию [во введении](https://www.freecodecamp.org/learn/apis-and-microservices/basic-node-and-express/) и начните новый проект на Glitch, используя [эту ссылку](https://glitch.com/edit/#!/remix/clone-from-repo?REPO_URL=https://github.com/freeCodeCamp/boilerplate-express/).

Измените файл `myApp.js` для вывода "Hello World" в консоль.



## Установка фреймворка Express

Для дальнейших действий у вас уже должен быть установлен Node.js. В терминале создайте каталог `myapp` и сделайте его рабочим.

```
mkdir myapp
cd myapp
```

С помощью команды `npm init` создайте файл `package.json`. 

```
npm init
```

Эта команда выдает целый ряд приглашений, например, приглашение указать имя и версию вашего приложения. На данный момент, достаточно просто нажать клавишу ВВОД, чтобы принять предлагаемые значения по умолчанию для большинства пунктов, кроме следующего:

```
entry point: (index.js)
```

Введите app.js или любое другое имя главного файла по своему желанию. Если вас устраивает index.js, нажмите клавишу ВВОД, чтобы принять предложенное имя файла по умолчанию.

Теперь установите Express в каталоге `myapp`:

```
npm install express
```
После установки в каталоге `myapp` будут находится два файла `package.json`, `package-lock.json` и каталог `node_modules`.

## Начало работы фреймворка Express

В каталоге `myapp` создайте файл с именем `index.js` и скопируйте в него следующий код:

```js
// подключение express
const express = require("express");
// создание объекта app
const app = express();
// для маршрута "/" определяется обработчик 
app.get("/", function(req, res){     
    // отправление ответа
    res.send("<h1>Главная страница</h1>");
});
// метод listen сообщает вашему серверу, прослушивать порт 3000
app.listen(3000);
```

Вы создали простейшее приложение Express. Теперь запустите приложение из терминала. Для этого в рабочем каталоге `myapp` введите следующую команду:

```
node index.js
```

После этого откройте в браузере страницу http://localhost:3000/ и вы увидите заголовок первого уровня "Главная страница".

![Главная страница](images/home-page.png)

Приложение выдает ответ “Главная страница” на запросы, адресованные корневому URL (/) или ***маршруту***. Для всех остальных путей ответом будет **404 Not Found**.

Функция `app.get(МАРШРУТ, ОБРАБОТЧИК)` сравнивает поступивший GET-запрос с `МАРШРУТ'ом` и если они совпадают срабатывает `ОБРАБОТЧИК`. В методе `app.get` первый параметр - это относительный путь (маршрут) на сервере, который можно задать не только в виде строки, но и в виде регулярного выражения.

`req` (запрос) и `res` (ответ) являются теми же объектами, которые предоставляет Node, поэтому можно вызвать `req.pipe()`, `req.on('data', callback)` и выполнить любые другие действия, не требующие участия Express.

Добавьте еще один маршрут и соответствующий ему обработчик. Для этого в файле `index.js` измените код на следующий:

```js
const express = require("express");
const app = express();

app.get("/", function(req, res){       
    res.send("<h1>Главная страница</h1>");
});
app.get("/contact", function(req, res){     
    res.send("<h1>Контакты</h1>");
});

app.listen(3000);
```

Теперь сервер сможет обрабатывать два маршрута в приложении: http://localhost:3000/ и http://localhost:3000/contact. Таким образом, можно добавить любое количество маршрутов с соответствующими обработчиками. 

Если в браузере перейти по адресу http://localhost:3000/contact, то вы увидите страницу с заголовком первого уровня "Контакты".

<a name="restart-node"></a>

**Для того чтобы увидеть результаты изменений необходимо перезапускать Node и обновлять браузер после каждой правки исходного кода.**

Чтобы перезапустить Node нужно:

* остановить приложение – CTRL+C;
* вернуться к предыдущей команде в терминале – UP;
* запустить приложение снова – ENTER.

Для того, чтобы избавится от такой "рутины", можно установить какой-нибудь инструмент, который позволит автоматизировать этот процесс, например:

* [nodemon](https://github.com/remy/nodemon);
* [supervisor](https://github.com/isaacs/node-supervisor);
* [forever](https://github.com/foreverjs/forever).

## Отправка HTML-файла

В предыдущем параграфе на клиентские (браузерные) GET-запросы серверные обработчики выдавали тот или иной HTML текст. В качестве ответа на запрос может быть выдан не только HTML текст, но и файлы, например, изображения, файлы CSS и JavaScript. Для этого в обработчик маршрута `app.get('/', ...)` нужно поместить метод `res.sendFile(path)`. 

Создайте каталог `pages`, а в нем файл `articles.html`, в который скопируйте следующий код:

```html
<!DOCTYPE html>
<html>
<head>
    <title>Статьи</title>
    <meta charset="utf-8" />
</head>
<body>
    <h1>Статьи</h1>
</body>
<html>
```
Затем измените файл `index.js`:

```js
const express = require("express");
const app = express();

app.get("/", function (req, res) {
    res.sendFile(__dirname + "/pages/articles.html");
});

app.listen(3000);
```
Даный код отправяет файл `/pages/articles.html` в качестве ответа на GET запрос. Запросом здесь является корневой маршрут `/`.

[Перезапустите Node](#restart-node) и в браузере перейдите по адресу http://localhost:3000, вы увидите заголовок первого уровня "Статьи".

![Статьи]()

Метод `sendFile()` сообщает браузеру тип файла и в зависимости от типа файла браузер будет знать, как обрабатывать файл. Затем метод прочитает и отправит файл. Путь к файлу `path` в этом методе должен быть абсолютным. Для вычисления абсолютного пути рекомендуется использовать глобальную переменную Node `__dirname`:

```js
absolutePath = __dirname + 'relativePath/file.ext'
```
`__dirname` возвращает полный путь к текущему каталогу.

## Выдача статических ресурсов

HTML сервер обычно имеет один или несколько каталогов, доступных пользователю. В этих каталогах обычно размещаются статические ресурсы, такие как, файлы CSS, JavaScript, изображения. В ответ на запросы пользователя сервер должен уметь предоставлять эти ресурсы. В Express эта функциональность реализуется с помощью функции промежуточной обработки (middleware) `express.static(path)`, где параметр `path` является **абсолютным** путем к папке, содержащей ресурсы. `middleware` должна быть установлена с помощью `app.use(path, middlewareFunction)`. Первый аргумент `path` является необязательным. Если вы не укажете его, `middlewareFunction` будет выполнена для всех запросов.

Создадайте в каталоге `pages` новую html-страницу `about.html` со следующим содержимым:

```html
<!DOCTYPE html>
<html>
<head>
    <title>О сайте</title>
    <meta charset="utf-8" />
</head>
<body>
    <h1>О сайте</h1>
</body>
<html>
```

В файле `index.js` измените код на следующий:

```js
const express = require("express"); 
const app = express(); 

app.use(express.static(__dirname + "/pages"));
 
app.use("/", function(req, res){     
    res.send("<h1>Главная страница</h1>");
});
 
app.listen(3000);
```

[Перезапустите Node](#restart-node) и в браузере перейдите по адресу http://localhost:3000/about.html либо http://localhost:3000/articles.html, вы увидите заголовок первого уровня "О сайте" либо "Статьи", соответственно. При переходе по любому другому адресу вы увидите заголовок первого уровня "Главная страница". 

Обратите внимание, что в строке запроса не указан каталог `pages`. Этот каталог указан в функции `static(__dirname + "/pages")`, которая говорит серверу Node, чтобы тот сопоставлял пользовательские запросы относительно указанной директории по умолчанию. Такой механизм позволяет не только сокращать путь в запросах к файлам, но и изменять маршруты не меняя положение самих файлов в каталогах, например:

```js
const express = require("express"); 
const app = express();
 
app.use("/static", express.static(__dirname + "/pages"));
 
app.use("/", function(req, res){     
    res.send("<h1>Главная страница</h1>");
});
 
app.listen(3000);
```

Теперь если мы хотим обратиться к файлу `about.html` или `articles.html`, необходимо отправить запрос http://localhost:3000/static/about.html или http://localhost:3000/static/articles.html соответственно (хотя, фактически, эти файлы расположены в директории `/pages`, а директория `/static` является виртуальной). Любые другие запросы будут выдавать заголовок первого уровня "Главная страница".

## Выдача JSON на определенном маршруте

В то время как сервер HTML обслуживает HTML, API обслуживает данные. API REST (REpresentational State Transfer) [[1](https://ru.wikipedia.org/wiki/REST)],[[2](https://habr.com/ru/post/265845/)] позволяет обмениваться данными простым способом, без необходимости для клиентов знать какие-либо детали о сервере. Клиенту нужно только знать, где находится ресурс (URL-адрес), и действие, которое он хочет выполнить с этим ресурсом (GET, POST, PUT и т.д.). Так, команда GET используется, когда вы хотите получить некоторую информацию, ничего при этом не изменяя. В наши дни предпочтительным форматом данных для перемещения информации по сети является JSON. Проще говоря, JSON - это удобный способ представления объекта JavaScript в виде строки, поэтому он может быть легко передан.

```js
app.get("/json", (req, res) => {
  res.json({
    message: "Hello json"
  });
});
```

Данный код представляет простой API, который отвечает строкой JSON на путь `/json`. Метод `app.get()` содержит путь `/json` и функцию-обработчик маршрута. Внутри обработчика маршрута используется метод `res.json()`, который передает объект в качестве аргумента. Этот метод закрывает цикл запрос-ответ, возвращая данные. Под капотом, он преобразует допустимый объект JavaScript в строку, затем устанавливает соответствующие заголовки, чтобы сообщить вашему браузеру, что вы формируете JSON, и отправляет данные обратно. Объект имеет обычную структуру `{key: data}`. Значение `data` может быть числом, строкой, вложенным объектом или массивом. Значение `data` также может быть переменной или результатом вызова функции, в этом случае они будут вычислены перед преобразованием в строку.

Теперь измените файл `index.js` следующим образом:

```js
const express = require("express"); 
const app = express();
 
app.use("/static", express.static(__dirname + "/pages"));

app.get("/json", (req, res) => {
  res.json({
    message: "Hello json"
  });
});
 
app.use("/", function(req, res){     
    res.send("<h1>Главная страница</h1>");
});

app.listen(3000);
```

В этом коде, чтобы все запросы срабатывали правильно, нужно методы `app.NAME(...)` располагать именно в такой последовательности. Если вы поменяете очередность, например, `app.use("/", ...)` расположите выше, чем `app.get("/json", ...)`, то запрос с маршрутом `"/json"` никогда не сработает. Вместо него будет срабатывать запрос `"/"`.

## Использование .env файла

Файл `.env` - это скрытый файл, который используется для хранения переменных окружения (переменных среды) [[1]](https://medium.com/@hydrock/%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D0%BE%D0%BA%D1%80%D1%83%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B2-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B8-node-js-e9ca2131e6b6). Этот файл является секретным, никто, кроме вас, не может получить к нему доступ, и он может быть использован для хранения данных, которые вы хотите сохранить конфиденциальными или скрытыми. Например, можно хранить ключи API из внешних служб или URI базы данных. Вы также можете использовать его для хранения параметров конфигурации. Задав параметры конфигурации, можно изменить поведение вашего приложения, не прибегая к переписыванию некоторого кода.

Переменные окружения в файле `.env` записываются в формате `VAR_NAME=value`, где `VAR_NAME` - имя переменной, а `value` - значение переменной. Каждую переменную окружения принято записывать с новой строки, например:

```
PORT=65091
ID=002
```

Не следует включать файл .env в ваш репозиторий, иначе конфиденциальные данные в этом файле будут доступны всем. Поэтому всегда добавляйте файл .env в список исключений файла .gitignore.

Переменные окружения доступны из приложения как `process.env.VAR_NAME`. Объект `process.env` является глобальным объектом Node, а переменные передаются в виде строк. По соглашению все имена переменных должны быть прописными, а слова разделены символом подчеркивания. Файл `.env` - это шелл файл, поэтому вам не нужно заключать имена или значения в кавычки. Также важно отметить, что при присвоении значений переменным, например `VAR_NAME=value`, вокруг знака равенства не должно быть пробелов.

Добавте переменную окружения в качестве опции конфигурации. Сохраните переменную `MESSAGE_STYLE=uppercase` в файле `.env`. Теперь измените файл `index.js` следующим образом:

```js
const express = require("express"); 
const app = express();
 
app.use("/static", express.static(__dirname + "/pages"));

app.get("/json", (req, res) => {    
    var msg = "Hello json"
    if (process.env.MESSAGE_STYLE === 'uppercase') {
        msg = "Hello json".toUpperCase()
    }
    res.json({message: msg}); 

});

app.listen(3000);
```

В этом коде обработчик маршрута GET `/json`, преобразует ответ объекта `message` в верхний регистр если `process.env.MESSAGE_STYLE` равен `uppercase`. Ответом будет `{"message": "HELLO JSON"}`.

## Реализация регистратора запроса промежуточного обработчика корневого уровня 

Ранее вы познакомились с функцией промежуточной обработки `express.static()`. Теперь пришло время посмотреть, что такое **промежуточный обработчик** (middleware), более подробно. Функции промежуточной обработки - это функции, которые принимают 3 аргумента: объект запроса (req), объект ответа (res) и следующую функцию промежуточной обработки в цикле запрос-ответ приложения. Эти функции выполняют некоторый код, который может иметь побочные эффекты для приложения, и обычно добавляют информацию к объектам запроса или ответа. Они также могут завершить цикл, отправив ответ, когда какое-то условие будет выполнено. Если они не отправят ответ, когда они закончат, они начнут выполнение следующей функции в стеке. Это приводит к вызову 3-го аргумента `next()`.

Посмотрите на следующий пример:

```js
var app = express();

app.use(function (req, res, next) {
  console.log('Время:', Date.now());
  next();
});
```

Здесь, в обработчике маршрута сам маршрут не указан, поэтому функция будет выполнятся при любом запросе. Когда поступает любой запрос с любым маршрутом, функция отображает в консоле количество миллисекунд, прошедших с 1 января 1970 года, а затем выполняет следующую функцию в стеке. 

Как вы уже видели в параграфе "Выдача статических ресурсов", для монтирования функции промежуточной обработки на корневом уровне вы можете использовать  метод `app.use(<mware-function>)`. В этом случае функция будет выполняться для всех запросов, но вы также можете установить более конкретные условия. Например, если вы хотите, чтобы функция выполнялась только для POST запросов, вы можете использовать `app.post(<mware-function>)`. Аналогичные методы существуют для всех HTTP команд (GET, DELETE, PUT, ...).

```js
app.use(function asd(req, res, next) {
  var string = req.method + " " + req.path + " - " + req.ip;
  console.log(string)
  next();
});
```

Для каждого запроса он должен регистрировать в консоли строку следующего формата: `method path-ip`. Пример будет выглядеть так: `GET /json - :: ffff: 127.0.0.1`. Обратите внимание, что между методом и путем есть пробел и что тире, разделяющее путь и ip, окружено пробелом с обеих сторон. Вы можете получить метод запроса (HTTP команда), относительный путь маршрута и ip-адрес вызывающего объекта из объекта запроса с помощью `req.method`, `req.path` и `req.ip` соответственно. Не забудьте вызвать `next()`, когда вы закончите, или ваш сервер застрянет навсегда. Обязательно откройте 'Логи' и посмотрите, что произойдет, когда придет какой-то запрос.

Примечание: Express вычисляет функции в том порядке, в котором они появляются в коде. Это справедливо и для промежуточных обработчиков. Если вы хотите, чтобы он работал для всех маршрутов, он должен быть установлен перед ними.

## Связывание промежуточных обработчиков для создания сервера времени

Промежуточные обработчики могут быть смонтированы на определенном маршруте с помощью `app.METHOD(path, middlewareFunction)`. Промежуточные обработчики также могут быть связаны внутри определенного маршрута.

Посмотрите на следующий пример:

```js
const express = require("express"); 
const app = express();

app.get(
  "/now",
  (req, res, next) => {
    req.time = new Date().toString();
    next();
  },
  (req, res) => {
    res.send({
      time: req.time
    });
  }
);

app.listen(3000);
```

В маршруте `app.get('/now', ...)` связаны функции промежуточного обработчика и конечного обработчика. В функцию промежуточного обработчика добавлена функция для вычисления текущего времени `new Date().toString()`. Конечный обработчик отвечает JSON объектом в виде `{"time":"Fri Jan 03 2020 17:45:06 GMT+0300 (GMT+03:00)"}`.

Вышеприведенный код можно переписать по-другому:

```js
const express = require("express"); 
const app = express();

const middleware = (req, res, next) => {
  req.time = new Date().toString();
  next();
};

app.get("/now", middleware, (req, res) => {
  res.send({
    time: req.time
  });
});

app.listen(3000);
```
Здесь зараннее определяется константа `middleware`, которую удобно использовать для нескольких маршрутов.

Этот подход полезен для разделения серверных операций на более мелкие единицы. Это приводит к лучшей структуре приложения и возможности повторного использования кода в разных местах. Этот подход также можно использовать для выполнения некоторой проверки данных. В каждой точке стека промежуточного обработчика можно заблокировать выполнение текущей цепочки и передать управление функциям, специально предназначенным для обработки ошибок. Или вы можете передать управление следующему соответствующему маршруту, чтобы обрабатывать особые случаи. Мы увидим, как это делается в разделе advanced Express.

## Получение входных параметров от клиента с помощью маршрута 

При создании API вы должны позволить пользователям сообщать вам, что они хотят получить от вашего сервиса. Например, если клиент запрашивает информацию о пользователе, хранящемся в базе данных, ему нужен способ сообщить вам, какой пользователь его интересует. Один из возможных способов достижения этого результата - использование параметров маршрута. Параметры маршрута называются сегментами URL-адреса, разделенными косыми чертами (/). Каждый сегмент фиксирует значение той части URL-адреса, которая соответствует его положению. Полученное значение можно найти в объекте `req.params`.

```
route_path: '/user/:userId/book/:bookId'
actual_request_URL: '/user/546/book/6754'
req.params: {userId: '546', bookId: '6754'}
```

Чтобы получить параметры маршрута из POST запроса, общий формат выглядит следующим образом:

```js
app.post("/:param1/:param2", (req, res) => {
  // Доступ к соответствующему ключу объекта req.params
  //  определен после последней точки
  var param1 = req.params.parameter1;
  // или используйте деструкцию для получения нескольких параметров
  var { param1, param2 } = req.params;
  // Отправка объекта req.params в качестве JSON ответа
  res.json(req.params);
});
```
Реальный пример выглядит так

```js
const express = require("express"); 
const app = express();
 
app.get("/user/:name", (req, res) => {
  const { name } = req.params;
  res.json({
    user: name
  });
});

app.listen(3000);
```

Если вы введете в адресную строку браузера, например `http://localhost:3000/user/Ivan`, то в окне браузера отобразится `{"user":"Ivan"}`. Таким образом, введенный пользователем параметр находится в `req.params.name`.

## Получение входных параметров от клиента с помощью строки запроса

Другой распространенный способ получения входных данных от клиента - это кодирование данных после пути маршрута с помощью строки запроса. Строка запроса разделяется вопросительным знаком (?), и включает пары `field=value`. Каждая пара разделена амперсандом (&). Express может анализировать данные из строки запроса и заполнять объект `req.query` этими данными. Некоторые символы, такие как процент (%), не могут быть в URL-адресах и должны быть закодированы в другом формате, прежде чем вы сможете отправить их. Если вы используете API из JavaScript, вы можете использовать определенные методы для кодирования/декодирования этих символов.

```
route_path: '/library'
actual_request_URL: '/library?userId=546&bookId=6754'
req.query: {userId: '546', bookId: '6754'}
```
Взгляните на следующий код

```js
const express = require("express"); 
const app = express();
 
app.get("/name", function(req, res) {
  var firstName = req.query.first;
  var lastName = req.query.last;    
  res.json({
    Имя: firstName + " " + lastName
  });
});

app.listen(3000);
```

Если в адресной строке браузера ввести, например, `http://localhost:3000/name?first=Ivan&last=Petrov`, то данный код выводит в окне браузера `{"Имя":"Ivan Petrov"}`

Тот же самый результат получится, если вы деструктурируете и переименуете ключи

```js
const express = require("express"); 
const app = express();
 
app.get("/name", function(req, res) {  
  var { first: firstName, last: lastName } = req.query;
  // Используйте литералы шаблона для создания форматированной строки
  res.json({
    Имя: `${firstName} ${lastName}`
  });
});

app.listen(3000);
```

## Использование body-parser для анализа POST запросов

Кроме GET, есть еще один распространенный HTTP запрос, это POST. POST - это метод, используемый по умолчанию для отправки клиентских данных с помощью HTML форм. По соглашению REST метод POST используется для отправки данных, создавая новые элементы в базе данных (новый пользователь или новая запись в блоге). У вас нет базы данных в этом проекте, но вы все равно научитесь обрабатывать POST запросы.

В таких запросах данные не отображаются в URL-адресе, они скрыты в теле запроса. Это часть HTML-запроса, называется полезными данными (payload). Поскольку HTML основан на тексте, даже если вы не видите данные, это не означает, что они являются секретными. Необработанное содержимое HTTP запроса POST показано ниже:

```
POST /path/subpath HTTP/1.0
From: john@example.com
User-Agent: someBrowser/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 20
name=John+Doe&age=25
```

Как видите, тело кодируется как строка запроса. Это формат по умолчанию, используемый HTML формами. С помощью Ajax вы также можете использовать JSON для обработки данных, имеющих более сложную структуру. Существует также другой тип кодирования: multipart/form-data. Он используется для загрузки двоичных файлов. 

В этом параграфе будет использоваться URL-закодированное структура. Для анализа данных, поступающих из POST-запросов форм, необходимо установить пакет [body-parser](https://github.com/expressjs/body-parser). Этот пакет позволяет использовать ряд промежуточных обработчиков, которые могут декодировать данные в различных форматах. Все промежуточные обработчики этого пакета заполняют свойство `req.body`.

Установите модуль `body-parser` в свой проект. Для этого перейдите в каталог проекта и наберите в терминале команду: 

```
npm install body-parser
```

Пакет будет добавлен в качестве зависимости в файл `package.json`:

```json
"dependencies": {
    "body-parser": "1.19.0",    
    "express": "4.17.1"
}
```

Создадим в папке `/pages` новый файл `register.html` и скопируем в него следующее:

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Регистрация</title>
    <meta charset="utf-8" />
  </head>
  <body>
    <h1>Введите имя и фамилию</h1>
    <form action="/register" method="post">
      <label>Имя</label><br />
      <input type="text" name="firstUserName" /><br /><br />
      <label>Фамилия</label><br />
      <input type="text" name="lastUserName" /><br /><br />
      <input type="submit" value="Отправить" />
    </form>
  </body>
</html>
```

В файл index.js скопируем следующий код:

```js
const express = require('express')
const bodyParser = require('body-parser')
const app = express()

// создаем парсер для данных application/x-www-form-urlencoded
const urlencodedParser = bodyParser.urlencoded({ extended: false })

app.use('/register', urlencodedParser, function(req, res) {
  res.sendFile(__dirname + '/register.html')
})
app.post('/register', urlencodedParser, function(req, res) {
  if (!req.body) return res.sendStatus(400)
  console.log(req.body)
  res.send(`${req.body.firstUserName} - ${request.body.lastUserName}`)
})

app.get('/', function(req, res) {
  res.send('Главная страница')
})

app.listen(3000)
```



При переходе по адресу `/register` срабатает метод `app.use`, который отправит пользователю файл `register.html`.

Здесь созданы два поля для ввода имени и фамилии пользователя. После того, как будет нажата кнопка "Отправить" данные будут отправлены по адресу `/register`.

Примечание: `extended: false` - это параметр конфигурации, который указывает синтаксическому анализатору использовать классическую кодировку. При его использовании значения могут быть только строками или массивами. Расширенная версия обеспечивает большую гибкость данных, но она превосходит JSON.


 
Так как данные отправляются с помощью метода POST, то для обработки определяем функцию app.post("/register",...). Первый параметр функции - адрес, на который идет отправка - /register. Стоит отметить, что в данном случае с одинм адресом /register связаны две функции, только одна обрабатывает запросы get, а другая - запросы post. Второй параметр - выше созданный парсер. Третий параметр - обработчик:


app.post('/register', urlencodedParser, function(request, response) {
  if (!request.body) return response.sendStatus(400)
  console.log(request.body)
  response.send(`${request.body.userName} - ${request.body.userAge}`)
})
Для получения самих отправленных данных используем выражения типа request.body.userName, где request.body инкапсулирует данные формы, а userName - ключ данных, который соответствует значению атрибута name поля ввода на html-странице:


<input type="text" name="userName" />
Запустим приложение и обратимся к странице register.html:

Затем запросите модуль `body-parser` в свой файл как `bodyParser`. Для этого нужно добавить следующую строку в верхней части вашего файла:

```js
var bodyParser = require('body-parser');
```

Все, что вам нужно сделать для этой задачи, это передать промежуточнный обработчик в `app.use()`. Убедитесь, что он приходит перед путями, на которых он должен быть использован. Помните, что body-parser возвращается вместе с `bodyParser.urlencoded({extended: false})`. Используйте в качестве шаблона следующее:

```js
app.use(bodyParser.urlencoded({ extended: false }));
```



Чтобы проанализировать данные JSON, отправленные в POST запросе, используйте `bodyParser.json()` в качестве промежуточного обработчика, как показано ниже:

```js
app.use(bodyParser.json());
```

Данные, полученные в запросе, доступны в объекте `req.body`.

Не забывайте, что все эти утверждения должны идти выше любых маршрутов, которые могли бы быть определены.






Используемые ресурсы:

* https://expressjs.com
* https://metanit.com/web/nodejs
* https://developer.mozilla.org/ru/docs/Learn/Server-side/Express_Nodejs
* https://www.freecodecamp.org/learn/apis-and-microservices/basic-node-and-express
* https://dev-gang.ru/article/sozdanie-api-interfeisa-nodejs-express-dlja-preobrazovanija-markdown-v-html-pwdqkjtn1g/