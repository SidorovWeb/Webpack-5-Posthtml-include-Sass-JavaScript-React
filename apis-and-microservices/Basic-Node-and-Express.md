---
title: Основы Node и Express
data: 18.12.2019
---

## Введение

Node.js - это среда выполнения JavaScript, которая позволяет разработчикам писать бэкэнд (серверные) программы на JavaScript. Node.js поставляется с несколькими встроенными модулями - небольшими независимыми программами, которые помогают облегчить эту задачу. Некоторые из основных модулей включают в себя:

+ HTTP: модуль, который действует как сервер
+ File System: модуль, который читает и изменяет файлы
+ Path: модуль для работы с каталогами и путями к файлам
+ Assertion Testing: модуль, который проверяет код на соответствие предписанным ограничениям

Express является еще одним модулем, который часто используется с Node.js, но не входит в него. Express - это фреймворк web-приложений для Node.js. Express выполняется между созданным Node.js сервером и фронтендом веб-приложения. Express также обрабатывает маршрутизацию приложения. Маршрутизация направляет пользователей на нужную страницу в зависимости от их взаимодействия с приложением. Хотя существуют альтернативы использованию Express, его простота делает его хорошим местом для начала при изучении взаимодействия между бэкэндом, работающим на Node.js и фронтендом.

Работа над этими заданиями будет включать в себя написание кода на Glitch в нашем стартовом проекте. После завершения каждого задания вы можете скопировать свой публичный URL-адрес Glitch (на домашнюю страницу вашего приложения) в экран задания, чтобы проверить его! При желании вы можете написать свой проект на другой платформе, но он должен быть публично виден для нашего тестирования.

Запустите этот проект на Glitch с помощью шаблона [Backend Challenges Boilerplate](https://glitch.com/edit/#!/remix/clone-from-repo?REPO_URL=https://github.com/freeCodeCamp/boilerplate-express/) (необходимо, если вы используете Glitch) или клонируйте [этот репозиторий](https://github.com/freeCodeCamp/boilerplate-express/) на GitHub! Если вы используете Glitch, не забудьте сохранить ссылку на ваш проект в безопасном месте!

## Знакомство с консолью Node

В процессе разработки важно иметь возможность проверить, что происходит в вашем коде. Node - это просто среда выполнения JavaScript. Как и на клиентском JavaScript, вы можете использовать консоль для отображения полезной отладочной информации. На локальном компьютере вы увидите консоль вывода в терминале. На Glitch вы можете открыть логи в нижней части экрана. Вы можете переключить панель журнала с помощью кнопки ‘Logs’ (внизу слева, в меню "Tools").

Мы рекомендуем держать панель журнала открытой во время работы над этими заданиями. Читая журналы, вы можете быть осведомлены о характере ошибок, которые могут возникнуть.

Если вы еще не сделали этого, пожалуйста, прочитайте инструкцию [во введении](https://www.freecodecamp.org/learn/apis-and-microservices/basic-node-and-express/) и начните новый проект на Glitch, используя [эту ссылку](https://glitch.com/edit/#!/remix/clone-from-repo?REPO_URL=https://github.com/freeCodeCamp/boilerplate-express/).

Измените файл `myApp.js` для вывода "Hello World" в консоль.



## Установка фреймворка Express

Для дальнейших действий у вас уже должен быть установлен Node.js. В терминале создайте каталог `myapp` и сделайте его рабочим.

```
$ mkdir myapp
$ cd myapp
```

С помощью команды `npm init` создайте файл `package.json`. 

```
$ npm init
```

Эта команда выдает целый ряд приглашений, например, приглашение указать имя и версию вашего приложения. На данный момент, достаточно просто нажать клавишу ВВОД, чтобы принять предлагаемые значения по умолчанию для большинства пунктов, кроме следующего:

```
entry point: (index.js)
```

Введите app.js или любое другое имя главного файла по своему желанию. Если вас устраивает index.js, нажмите клавишу ВВОД, чтобы принять предложенное имя файла по умолчанию.

Теперь установите Express в каталоге `myapp`:

```
$ npm install express
```
После установки в каталоге `myapp` будут находится два файла `package.json`, `package-lock.json` и каталог `node_modules`.

## Начало работы фреймворка Express

В каталоге `myapp` создайте файл с именем `index.js` и скопируйте в него следующий код:

```js
// подключение express
const express = require("express");
// создание объекта app
const app = express();
// для маршрута "/" определяется обработчик 
app.get("/", function(req, res){     
    // отправление ответа
    res.send("<h1>Главная страница</h1>");
});
// метод listen сообщает вашему серверу, прослушивать порт 3000
app.listen(3000);
```

Вы создали простейшее приложение Express. Теперь запустите приложение из терминала. Для этого в рабочем каталоге `myapp` введите следующую команду:

```
$ node index.js
```

После этого откройте в браузере страницу http://localhost:3000/ и вы увидите заголовок первого уровня "Главная страница".

![Главная страница](images/home-page.png)

Приложение выдает ответ “Главная страница” на запросы, адресованные корневому URL (/) или ***маршруту***. Для всех остальных путей ответом будет **404 Not Found**.

Функция `app.get(МАРШРУТ, ОБРАБОТЧИК)` сравнивает поступивший GET-запрос с `МАРШРУТ'ом` и если они совпадают срабатывает `ОБРАБОТЧИК`. В методе `app.get` первый параметр - это относительный путь (маршрут) на сервере, который может быть не только строкой, но и регулярным выражением.

`req` (запрос) и `res` (ответ) являются теми же объектами, которые предоставляет Node, поэтому можно вызвать `req.pipe()`, `req.on('data', callback)` и выполнить любые другие действия, не требующие участия Express.

Добавьте еще один маршрут и соответствующий ему обработчик. Для этого в файле `index.js` измените код на следующий:

```js
const express = require("express");
const app = express();

app.get("/", function(req, res){       
    res.send("<h1>Главная страница</h1>");
});
app.get("/contact", function(req, res){     
    res.send("<h1>Контакты</h1>");
});

app.listen(3000);
```

Теперь сервер сможет обрабатывать два маршрута в приложении: http://localhost:3000/ и http://localhost:3000/contact. Таким образом, можно добавить любое количество маршрутов с соответствующими обработчиками. 

Если в браузере перейти по адресу http://localhost:3000/contact, то вы увидите страницу с заголовком первого уровня "Контакты".

<a name="restart-node"></a>

**Для того чтобы увидеть результаты изменений необходимо перезапускать Node и обновлять браузер после каждой правки исходного кода.**

Чтобы перезапустить Node нужно:

* остановить приложение – CTRL+C;
* вернуться к предыдущей команде в терминале – UP;
* запустить приложение снова – ENTER.

Для того, чтобы избавится от такой "рутины", можно установить какой-нибудь инструмент, который позволит автоматизировать этот процесс, например:

* [nodemon](https://github.com/remy/nodemon);
* [supervisor](https://github.com/isaacs/node-supervisor);
* [forever](https://github.com/foreverjs/forever).

## Отправка HTML-файла

В предыдущем параграфе на клиентские (браузерные) GET-запросы серверные обработчики выдавали тот или иной HTML текст. В качестве ответа на запрос может быть выдан не только HTML текст, но и файлы, например, изображения, файлы CSS и JavaScript. Для этого в обработчик маршрута `app.get('/', ...)` нужно поместить метод `res.sendFile(path)`. 

Создайте каталог `pages`, а в нем файл `articles.html`, в который скопируйте следующий код:

```html
<!DOCTYPE html>
<html>
<head>
    <title>Статьи</title>
    <meta charset="utf-8" />
</head>
<body>
    <h1>Статьи</h1>
</body>
<html>
```
Затем измените файл `index.js`:

```js
const express = require("express");
const app = express();

app.get("/", function (req, res) {
    res.sendFile(__dirname + "/pages/articles.html");
});

app.listen(3000);
```
Даный код отправяет файл `/pages/articles.html` в качестве ответа на GET запрос. Запросом здесь является корневой маршрут `/`.

[Перезапустите Node](#restart-node) и в браузере перейдите по адресу http://localhost:3000, вы увидите заголовок первого уровня "Статьи".

![Статьи]()

Метод `sendFile()` сообщает браузеру тип файла и в зависимости от типа файла браузер будет знать, как обрабатывать файл. Затем метод прочитает и отправит файл. Путь к файлу `path` в этом методе должен быть абсолютным. Для вычисления абсолютного пути рекомендуется использовать глобальную переменную Node `__dirname`:

```js
absolutePath = __dirname + 'relativePath/file.ext'
```
`__dirname` возвращает полный путь к текущему каталогу.

## Выдача статических ресурсов

HTML сервер обычно имеет один или несколько каталогов, доступных пользователю. В этих каталогах обычно размещаются статические ресурсы, такие как, файлы CSS, JavaScript, изображения. В ответ на запросы пользователя сервер должен уметь предоставлять эти ресурсы. В Express эта функциональность реализуется с помощью функции промежуточной обработки (middleware) `express.static(path)`, где параметр `path` является **абсолютным** путем к папке, содержащей ресурсы. `middleware` должна быть установлена с помощью `app.use(path, middlewareFunction)`. Первый аргумент `path` является необязательным. Если вы не укажете его, `middlewareFunction` будет выполнена для всех запросов.

Создадайте в каталоге `pages` новую html-страницу `about.html` со следующим содержимым:

```html
<!DOCTYPE html>
<html>
<head>
    <title>О сайте</title>
    <meta charset="utf-8" />
</head>
<body>
    <h1>О сайте</h1>
</body>
<html>
```

В файле `index.js` измените код на следующий:

```js
const express = require("express"); 
const app = express(); 

app.use(express.static(__dirname + "/pages"));
 
app.use("/", function(req, res){     
    res.send("<h1>Главная страница</h1>");
});
 
app.listen(3000);
```

[Перезапустите Node](#restart-node) и в браузере перейдите по адресу http://localhost:3000/about.html либо http://localhost:3000/articles.html, вы увидите заголовок первого уровня "О сайте" либо "Статьи", соответственно. При переходе по любому другому адресу вы увидите заголовок первого уровня "Главная страница". 

Обратите внимание, что в строке запроса не указан каталог `pages`. Такой механизм позволяет не только сокращать путь в запросах к файлам, но и изменять маршруты не меняя положение самих файлов в каталогах, например:

```js
const express = require("express"); 
const app = express();
 
app.use("/static", express.static(__dirname + "/pages"));
 
app.use("/", function(req, res){     
    res.send("<h1>Главная страница</h1>");
});
 
app.listen(3000);
```

Теперь если мы хотим обратиться к файлу `about.html` или `articles.html`, необходимо отправить запрос http://localhost:3000/static/about.html или http://localhost:3000/static/articles.html соответственно. Любые другие запросы будут выдавать главную страницу.

## Выдача JSON на определенном маршруте

В то время как сервер HTML обслуживает HTML, API обслуживает данные. API REST (REpresentational State Transfer) [[1](https://ru.wikipedia.org/wiki/REST)],[[2](https://habr.com/ru/post/265845/)] позволяет обмениваться данными простым способом, без необходимости для клиентов знать какие-либо детали о сервере. Клиенту нужно только знать, где находится ресурс (URL-адрес), и действие, которое он хочет выполнить с этим ресурсом (GET, POST, PUT и т.д.). Так, команда GET используется, когда вы хотите получить некоторую информацию, ничего при этом не изменяя. В наши дни предпочтительным форматом данных для перемещения информации по сети является JSON. Проще говоря, JSON - это удобный способ представления объекта JavaScript в виде строки, поэтому он может быть легко передан.

```js
app.get("/json", (req, res) => {
  res.json({
    message: "Hello json"
  });
});
```

Данный код представляет простой API, который отвечает строкой JSON на путь `/json`. Метод `app.get()` содержит путь `/json` и функцию-обработчик маршрута. Внутри обработчика маршрута используется метод `res.json()`, который передает объект в качестве аргумента. Этот метод закрывает цикл запрос-ответ, возвращая данные. Под капотом, он преобразует допустимый объект JavaScript в строку, затем устанавливает соответствующие заголовки, чтобы сообщить вашему браузеру, что вы формируете JSON, и отправляет данные обратно. Объект имеет обычную структуру `{key: data}`. Значение `data` может быть числом, строкой, вложенным объектом или массивом. Значение `data` также может быть переменной или результатом вызова функции, в этом случае они будут вычислены перед преобразованием в строку.

Теперь измените файл `index.js` следующим образом:

```js
const express = require("express"); 
const app = express();
 
app.use("/static", express.static(__dirname + "/pages"));

app.get("/json", (req, res) => {
  res.json({
    message: "Hello json"
  });
});
 
app.use("/", function(req, res){     
    res.send("<h1>Главная страница</h1>");
});

app.listen(3000);
```

В этом коде, чтобы все запросы срабатывали правильно, нужно методы `app.NAME(...)` располагать именно в такой последовательности. Если вы поменяете очередность, например, `app.use("/", ...)` расположите выше, чем `app.get("/json", ...)`, то запрос с маршрутом `"/json"` никогда не сработает. Вместо него будет срабатывать запрос `"/"`.

## Использование .env файла

Файл `.env` - это скрытый файл, который используется для хранения переменных окружения (переменных среды) [[1]](https://medium.com/@hydrock/%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D0%BE%D0%BA%D1%80%D1%83%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B2-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B8-node-js-e9ca2131e6b6). Этот файл является секретным, никто, кроме вас, не может получить к нему доступ, и он может быть использован для хранения данных, которые вы хотите сохранить конфиденциальными или скрытыми. Например, можно хранить ключи API из внешних служб или URI базы данных. Вы также можете использовать его для хранения параметров конфигурации. Задав параметры конфигурации, можно изменить поведение вашего приложения, не прибегая к переписыванию некоторого кода.

Переменные окружения в файле `.env` записываются в формате `VAR_NAME=value`, где `VAR_NAME` - имя переменной, а `value` - значение переменной. Каждую переменную окружения принято записывать с новой строки, например:

```
PORT=65091
ID=002
```

Не следует включать файл .env в ваш репозиторий, иначе конфиденциальные данные в этом файле будут доступны всем. Поэтому всегда добавляйте файл .env в список исключений файла .gitignore.

Переменные окружения доступны из приложения как `process.env.VAR_NAME`. Объект `process.env` является глобальным объектом Node, а переменные передаются в виде строк. По соглашению все имена переменных должны быть прописными, а слова разделены символом подчеркивания. Файл `.env` - это шелл файл, поэтому вам не нужно заключать имена или значения в кавычки. Также важно отметить, что при присвоении значений переменным, например `VAR_NAME=value`, вокруг знака равенства не должно быть пробелов.

Добавте переменную окружения в качестве опции конфигурации. Сохраните переменную `MESSAGE_STYLE=uppercase` в файле `.env`. Теперь измените файл `index.js` следующим образом:

```js
const express = require("express"); 
const app = express();
 
app.use("/static", express.static(__dirname + "/pages"));

app.get("/json", (req, res) => {    
    var msg = "Hello json"
    if (process.env.MESSAGE_STYLE === 'uppercase') {
        msg = "Hello json".toUpperCase()
    }
    res.json({message: msg}); 

});

app.listen(3000);
```

В этом коде обработчик маршрута GET `/json`, преобразует ответ объекта message в верхний регистр если `process.env.MESSAGE_STYLE` равен `uppercase`. Ответом будет `{"message": "HELLO JSON"}`.

## Реализация регистратора запроса корневого уровня промежуточного обработчика 

Ранее вы познакомились с функцией промежуточной обработки `express.static()`. Теперь пришло время посмотреть, что такое **промежуточный обработчик** (middleware), более подробно. Функции промежуточной обработки - это функции, которые принимают 3 аргумента: объект запроса (req), объект ответа (res) и следующую функцию промежуточной обработки в цикле запрос-ответ приложения. Эти функции выполняют некоторый код, который может иметь побочные эффекты для приложения, и обычно добавляют информацию к объектам запроса или ответа. Они также могут завершить цикл, отправив ответ, когда какое-то условие будет выполнено. Если они не отправят ответ, когда они закончат, они начнут выполнение следующей функции в стеке. Это приводит к вызову 3-го аргумента `next()`.

Посмотрите на следующий пример:

```js
function(req, res, next) {
  console.log("Я функция промежуточной обработки...");
  next();
}
```

Предположим, вы установили эту функцию на маршруте. Когда запрос совпадает с маршрутом, он отображает строку "Я функция промежуточной обработки...", а затем выполняет следующую функцию в стеке. В этом упражнении вы будете создавать функцию промежуточной обработки корневого уровня. Как вы уже видели в параграфе "Выдача статических ресурсов", для монтирования функции промежуточной обработки на корневом уровне вы можете использовать  метод `app.use(<mware-function>)`. В этом случае функция будет выполняться для всех запросов, но вы также можете установить более конкретные условия. Например, если вы хотите, чтобы функция выполнялась только для POST запросов, вы можете использовать `app.post(<mware-function>)`. Аналогичные методы существуют для всех HTTP команд (GET, DELETE, PUT, ...).

Постройте простой регистратор. Для каждого запроса он должен регистрировать в консоли строку следующего формата: `method path-ip`. Пример будет выглядеть так: `GET /json - :: ffff: 127.0.0.1`. Обратите внимание, что между методом и путем есть пробел и что тире, разделяющее путь и ip, окружено пробелом с обеих сторон. Вы можете получить метод запроса (HTTP команда), относительный путь маршрута и ip-адрес вызывающего объекта из объекта запроса с помощью `req.method`, `req.path` и `req.ip`. Не забудьте вызвать `next()`, когда вы закончите, или ваш сервер застрянет навсегда. Обязательно откройте 'Логи' и посмотрите, что произойдет, когда придет какой-то запрос.

Примечание: Express вычисляет функции в том порядке, в котором они появляются в коде. Это справедливо и для промежуточных обработчиков. Если вы хотите, чтобы он работал для всех маршрутов, он должен быть установлен перед ними.

Промежуточное ПО регистратора корневого уровня должно быть активным





Используемые ресурсы:

* https://expressjs.com
* https://metanit.com/web/nodejs
* https://developer.mozilla.org/ru/docs/Learn/Server-side/Express_Nodejs
* https://www.freecodecamp.org/learn/apis-and-microservices/basic-node-and-express
* https://dev-gang.ru/article/sozdanie-api-interfeisa-nodejs-express-dlja-preobrazovanija-markdown-v-html-pwdqkjtn1g/